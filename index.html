<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="KingDragon Baron" />










<meta name="description" content="Baron个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面">
<meta property="og:type" content="website">
<meta property="og:title" content="King Dragon">
<meta property="og:url" content="https://github.com/KingDragon-Baron/index.html">
<meta property="og:site_name" content="King Dragon">
<meta property="og:description" content="Baron个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="King Dragon">
<meta name="twitter:description" content="Baron个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/KingDragon-Baron/"/>





  <title>King Dragon</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">King Dragon</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Stay Hungry, Stay Foolish</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/KingDragon-Baron/2018/11/08/线程、进程、协程实现web静态服务器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Baron">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King Dragon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/08/线程、进程、协程实现web静态服务器/" itemprop="url">线程、进程、协程实现web静态服务器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-08T23:48:13+08:00">
                2018-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程、进程、协程实现web静态服务器"><a href="#线程、进程、协程实现web静态服务器" class="headerlink" title="线程、进程、协程实现web静态服务器"></a>线程、进程、协程实现web静态服务器</h2><hr>
<h6 id="1-Web静态服务器–多进程"><a href="#1-Web静态服务器–多进程" class="headerlink" title="1.Web静态服务器–多进程"></a>1.Web静态服务器–多进程</h6><pre><code>#coding=utf-8
import socket
import re
import multiprocessing


class WSGIServer(object):

    def __init__(self, server_address):
        # 创建一个tcp套接字
        self.listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 允许立即使用上次绑定的port
        self.listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # 绑定本地信息
        self.listen_socket.bind(server_address)
        # 变为被动，并制定队列的长度
        self.listen_socket.listen(128)

    def serve_forever(self):
        &quot;循环运行web服务器，等待客户端的链接并为客户端服务&quot;
        while True:
            # 等待新客户端到来
            client_socket, client_address = self.listen_socket.accept()
            print(client_address)  # for test
            new_process = multiprocessing.Process(target=self.handleRequest, args=(client_socket,))
            new_process.start()

            # 因为子进程已经复制了父进程的套接字等资源，所以父进程调用close不会将他们对应的这个链接关闭的
            client_socket.close()

    def handleRequest(self, client_socket):
        &quot;用一个新的进程，为一个客户端进行服务&quot;
        recv_data = client_socket.recv(1024).decode(&apos;utf-8&apos;)
        print(recv_data)
        requestHeaderLines = recv_data.splitlines()
        for line in requestHeaderLines:
            print(line)

        request_line = requestHeaderLines[0]
        get_file_name = re.match(&quot;[^/]+(/[^ ]*)&quot;, request_line).group(1)
        print(&quot;file name is ===&gt;%s&quot; % get_file_name) # for test

        if get_file_name == &quot;/&quot;:
            get_file_name = DOCUMENTS_ROOT + &quot;/index.html&quot;
        else:
            get_file_name = DOCUMENTS_ROOT + get_file_name

        print(&quot;file name is ===2&gt;%s&quot; % get_file_name) # for test

        try:
            f = open(get_file_name, &quot;rb&quot;)
        except IOError:
            response_header = &quot;HTTP/1.1 404 not found\r\n&quot;
            response_header += &quot;\r\n&quot;
            response_body = &quot;====sorry ,file not found====&quot;
        else:
            response_header = &quot;HTTP/1.1 200 OK\r\n&quot;
            response_header += &quot;\r\n&quot;
            response_body = f.read()
            f.close()
        finally:
            client_socket.send(response_header.encode(&apos;utf-8&apos;))
            client_socket.send(response_body)
            client_socket.close()


# 设定服务器的端口
SERVER_ADDR = (HOST, PORT) = &quot;&quot;, 8888
# 设置服务器服务静态资源时的路径
DOCUMENTS_ROOT = &quot;./html&quot;


def main():
    httpd = WSGIServer(SERVER_ADDR)
    print(&quot;web Server: Serving HTTP on port %d ...\n&quot; % PORT)
    httpd.serve_forever()

if __name__ == &quot;__main__&quot;:
    main()
</code></pre><h6 id="2-Web静态服务器–多线程"><a href="#2-Web静态服务器–多线程" class="headerlink" title="2.Web静态服务器–多线程"></a>2.Web静态服务器–多线程</h6><pre><code>#coding=utf-8
import socket
import re
import threading


class WSGIServer(object):

    def __init__(self, server_address):
        # 创建一个tcp套接字
        self.listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 允许立即使用上次绑定的port
        self.listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # 绑定
        self.listen_socket.bind(server_address)
        # 变为被动，并制定队列的长度
        self.listen_socket.listen(128)

    def serve_forever(self):
        &quot;循环运行web服务器，等待客户端的链接并为客户端服务&quot;
        while True:
            # 等待新客户端到来
            client_socket, client_address = self.listen_socket.accept()
            print(client_address)
            new_process = threading.Thread(target=self.handleRequest, args=(client_socket,))
            new_process.start()

            # 因为线程是共享同一个套接字，所以主线程不能关闭，否则子线程就不能再使用这个套接字了
            # client_socket.close() 

    def handleRequest(self, client_socket):
        &quot;用一个新的进程，为一个客户端进行服务&quot;
        recv_data = client_socket.recv(1024).decode(&apos;utf-8&apos;)
        print(recv_data)
        requestHeaderLines = recv_data.splitlines()
        for line in requestHeaderLines:
            print(line)

        request_line = requestHeaderLines[0]
        get_file_name = re.match(&quot;[^/]+(/[^ ]*)&quot;, request_line).group(1)
        print(&quot;file name is ===&gt;%s&quot; % get_file_name) # for test

        if get_file_name == &quot;/&quot;:
            get_file_name = DOCUMENTS_ROOT + &quot;/index.html&quot;
        else:
            get_file_name = DOCUMENTS_ROOT + get_file_name

        print(&quot;file name is ===2&gt;%s&quot; % get_file_name) # for test

        try:
            f = open(get_file_name, &quot;rb&quot;)
        except IOError:
            response_header = &quot;HTTP/1.1 404 not found\r\n&quot;
            response_header += &quot;\r\n&quot;
            response_body = &quot;====sorry ,file not found====&quot;
        else:
            response_header = &quot;HTTP/1.1 200 OK\r\n&quot;
            response_header += &quot;\r\n&quot;
            response_body = f.read()
            f.close()
        finally:
            client_socket.send(response_header.encode(&apos;utf-8&apos;))
            client_socket.send(response_body)
            client_socket.close()


# 设定服务器的端口
SERVER_ADDR = (HOST, PORT) = &quot;&quot;, 8888
# 设置服务器服务静态资源时的路径
DOCUMENTS_ROOT = &quot;./html&quot;


def main():
    httpd = WSGIServer(SERVER_ADDR)
    print(&quot;web Server: Serving HTTP on port %d ...\n&quot; % PORT)
    httpd.serve_forever()

if __name__ == &quot;__main__&quot;:
    main()
</code></pre><h6 id="3-Web静态服务器–非堵塞模式-并发原理"><a href="#3-Web静态服务器–非堵塞模式-并发原理" class="headerlink" title="3.Web静态服务器–非堵塞模式(并发原理)"></a>3.Web静态服务器–非堵塞模式(并发原理)</h6><pre><code>import time
import socket
import sys
import re


class WSGIServer(object):
    &quot;&quot;&quot;定义一个WSGI服务器的类&quot;&quot;&quot;

    def __init__(self, port, documents_root):

        # 1. 创建套接字
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 2. 绑定本地信息
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server_socket.bind((&quot;&quot;, port))
        # 3. 变为监听套接字
        self.server_socket.listen(128)

        self.server_socket.setblocking(False)
        self.client_socket_list = list()

        self.documents_root = documents_root

    def run_forever(self):
        &quot;&quot;&quot;运行服务器&quot;&quot;&quot;

        # 等待对方链接
        while True:

            # time.sleep(0.5)  # for test

            try:
                new_socket, new_addr = self.server_socket.accept()
            except Exception as ret:
                print(&quot;-----1----&quot;, ret)  # for test
            else:
                new_socket.setblocking(False)
                self.client_socket_list.append(new_socket)

            for client_socket in self.client_socket_list:
                try:
                    request = client_socket.recv(1024).decode(&apos;utf-8&apos;)
                except Exception as ret:
                    print(&quot;------2----&quot;, ret)  # for test
                else:
                    if request:
                        self.deal_with_request(request, client_socket)
                    else:
                        client_socket.close()
                        self.client_socket_list.remove(client_socket)

            print(self.client_socket_list)


    def deal_with_request(self, request, client_socket):
        &quot;&quot;&quot;为这个浏览器服务器&quot;&quot;&quot;
        if not request:
            return

        request_lines = request.splitlines()
        for i, line in enumerate(request_lines):
            print(i, line)

        # 提取请求的文件(index.html)
        # GET /a/b/c/d/e/index.html HTTP/1.1
        ret = re.match(r&quot;([^/]*)([^ ]+)&quot;, request_lines[0])
        if ret:
            print(&quot;正则提取数据:&quot;, ret.group(1))
            print(&quot;正则提取数据:&quot;, ret.group(2))
            file_name = ret.group(2)
            if file_name == &quot;/&quot;:
                file_name = &quot;/index.html&quot;


        # 读取文件数据
        try:
            f = open(self.documents_root+file_name, &quot;rb&quot;)
        except:
            response_body = &quot;file not found, 请输入正确的url&quot;
            response_header = &quot;HTTP/1.1 404 not found\r\n&quot;
            response_header += &quot;Content-Type: text/html; charset=utf-8\r\n&quot;
            response_header += &quot;Content-Length: %d\r\n&quot; % (len(response_body))
            response_header += &quot;\r\n&quot;

            # 将header返回给浏览器
            client_socket.send(response_header.encode(&apos;utf-8&apos;))

            # 将body返回给浏览器
            client_socket.send(response_body.encode(&quot;utf-8&quot;))
        else:
            content = f.read()
            f.close()

            response_body = content
            response_header = &quot;HTTP/1.1 200 OK\r\n&quot;
            response_header += &quot;Content-Length: %d\r\n&quot; % (len(response_body))
            response_header += &quot;\r\n&quot;

            # 将header返回给浏览器
            client_socket.send( response_header.encode(&apos;utf-8&apos;) + response_body)


# 设置服务器服务静态资源时的路径
DOCUMENTS_ROOT = &quot;./html&quot;


def main():
    &quot;&quot;&quot;控制web服务器整体&quot;&quot;&quot;
    # python3 xxxx.py 7890
    if len(sys.argv) == 2:
        port = sys.argv[1]
        if port.isdigit():
            port = int(port)
    else:
        print(&quot;运行方式如: python3 xxx.py 7890&quot;)
        return

    print(&quot;http服务器使用的port:%s&quot; % port)
    http_server = WSGIServer(port, DOCUMENTS_ROOT)
    http_server.run_forever()


if __name__ == &quot;__main__&quot;:
    main()
</code></pre><h6 id="4-Web静态服务器–epoll"><a href="#4-Web静态服务器–epoll" class="headerlink" title="4. Web静态服务器–epoll"></a>4. Web静态服务器–epoll</h6><pre><code>import socket
import time
import sys
import re
import select


class WSGIServer(object):
    &quot;&quot;&quot;定义一个WSGI服务器的类&quot;&quot;&quot;

    def __init__(self, port, documents_root):

        # 1. 创建套接字
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 2. 绑定本地信息
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server_socket.bind((&quot;&quot;, port))
        # 3. 变为监听套接字
        self.server_socket.listen(128)

        self.documents_root = documents_root

        # 创建epoll对象
        self.epoll = select.epoll()
        # 将tcp服务器套接字加入到epoll中进行监听
        self.epoll.register(self.server_socket.fileno(), select.EPOLLIN|select.EPOLLET)

        # 创建添加的fd对应的套接字
        self.fd_socket = dict()

    def run_forever(self):
        &quot;&quot;&quot;运行服务器&quot;&quot;&quot;

        # 等待对方链接
        while True:
            # epoll 进行 fd 扫描的地方 -- 未指定超时时间则为阻塞等待
            epoll_list = self.epoll.poll()

            # 对事件进行判断
            for fd, event in epoll_list:
                # 如果是服务器套接字可以收数据，那么意味着可以进行accept
                if fd == self.server_socket.fileno():
                    new_socket, new_addr = self.server_socket.accept()
                    # 向 epoll 中注册 连接 socket 的 可读 事件
                    self.epoll.register(new_socket.fileno(), select.EPOLLIN | select.EPOLLET)
                    # 记录这个信息
                    self.fd_socket[new_socket.fileno()] = new_socket
                # 接收到数据
                elif event == select.EPOLLIN:
                    request = self.fd_socket[fd].recv(1024).decode(&quot;utf-8&quot;)
                    if request:
                        self.deal_with_request(request, self.fd_socket[fd])
                    else:
                        # 在epoll中注销客户端的信息
                        self.epoll.unregister(fd)
                        # 关闭客户端的文件句柄
                        self.fd_socket[fd].close()
                        # 在字典中删除与已关闭客户端相关的信息
                        del self.fd_socket[fd]

    def deal_with_request(self, request, client_socket):
        &quot;&quot;&quot;为这个浏览器服务器&quot;&quot;&quot;

        if not request:
            return

        request_lines = request.splitlines()
        for i, line in enumerate(request_lines):
            print(i, line)

        # 提取请求的文件(index.html)
        # GET /a/b/c/d/e/index.html HTTP/1.1
        ret = re.match(r&quot;([^/]*)([^ ]+)&quot;, request_lines[0])
        if ret:
            print(&quot;正则提取数据:&quot;, ret.group(1))
            print(&quot;正则提取数据:&quot;, ret.group(2))
            file_name = ret.group(2)
            if file_name == &quot;/&quot;:
                file_name = &quot;/index.html&quot;


        # 读取文件数据
        try:
            f = open(self.documents_root+file_name, &quot;rb&quot;)
        except:
            response_body = &quot;file not found, 请输入正确的url&quot;

            response_header = &quot;HTTP/1.1 404 not found\r\n&quot;
            response_header += &quot;Content-Type: text/html; charset=utf-8\r\n&quot;
            response_header += &quot;Content-Length: %d\r\n&quot; % len(response_body)
            response_header += &quot;\r\n&quot;

            # 将header返回给浏览器
            client_socket.send(response_header.encode(&apos;utf-8&apos;))

            # 将body返回给浏览器
            client_socket.send(response_body.encode(&quot;utf-8&quot;))
        else:
            content = f.read()
            f.close()

            response_body = content

            response_header = &quot;HTTP/1.1 200 OK\r\n&quot;
            response_header += &quot;Content-Length: %d\r\n&quot; % len(response_body)
            response_header += &quot;\r\n&quot;

            # 将数据返回给浏览器
            client_socket.send(response_header.encode(&quot;utf-8&quot;)+response_body)


# 设置服务器服务静态资源时的路径
DOCUMENTS_ROOT = &quot;./html&quot;


def main():
    &quot;&quot;&quot;控制web服务器整体&quot;&quot;&quot;
    # python3 xxxx.py 7890
    if len(sys.argv) == 2:
        port = sys.argv[1]
        if port.isdigit():
            port = int(port)
    else:
        print(&quot;运行方式如: python3 xxx.py 7890&quot;)
        return

    print(&quot;http服务器使用的port:%s&quot; % port)
    http_server = WSGIServer(port, DOCUMENTS_ROOT)
    http_server.run_forever()


if __name__ == &quot;__main__&quot;:
    main()
</code></pre><h6 id="5-Web静态服务器–gevent版"><a href="#5-Web静态服务器–gevent版" class="headerlink" title="5.Web静态服务器–gevent版"></a>5.Web静态服务器–gevent版</h6><pre><code>from gevent import monkey
import gevent
import socket
import sys
import re

monkey.patch_all()


class WSGIServer(object):
    &quot;&quot;&quot;定义一个WSGI服务器的类&quot;&quot;&quot;

    def __init__(self, port, documents_root):

        # 1. 创建套接字
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 2. 绑定本地信息
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server_socket.bind((&quot;&quot;, port))
        # 3. 变为监听套接字
        self.server_socket.listen(128)

        self.documents_root = documents_root

    def run_forever(self):
        &quot;&quot;&quot;运行服务器&quot;&quot;&quot;

        # 等待对方链接
        while True:
            new_socket, new_addr = self.server_socket.accept()
            gevent.spawn(self.deal_with_request, new_socket)  # 创建一个协程准备运行它

    def deal_with_request(self, client_socket):
        &quot;&quot;&quot;为这个浏览器服务器&quot;&quot;&quot;
        while True:
            # 接收数据
            request = client_socket.recv(1024).decode(&apos;utf-8&apos;)
            # print(gevent.getcurrent())
            # print(request)

            # 当浏览器接收完数据后，会自动调用close进行关闭，因此当其关闭时，web也要关闭这个套接字
            if not request:
                new_socket.close()
                break

            request_lines = request.splitlines()
            for i, line in enumerate(request_lines):
                print(i, line)

            # 提取请求的文件(index.html)
            # GET /a/b/c/d/e/index.html HTTP/1.1
            ret = re.match(r&quot;([^/]*)([^ ]+)&quot;, request_lines[0])
            if ret:
                print(&quot;正则提取数据:&quot;, ret.group(1))
                print(&quot;正则提取数据:&quot;, ret.group(2))
                file_name = ret.group(2)
                if file_name == &quot;/&quot;:
                    file_name = &quot;/index.html&quot;

            file_path_name = self.documents_root + file_name
            try:
                f = open(file_path_name, &quot;rb&quot;)
            except:
                # 如果不能打开这个文件，那么意味着没有这个资源，没有资源 那么也得需要告诉浏览器 一些数据才行
                # 404
                response_body = &quot;没有你需要的文件......&quot;.encode(&quot;utf-8&quot;)

                response_headers = &quot;HTTP/1.1 404 not found\r\n&quot;
                response_headers += &quot;Content-Type:text/html;charset=utf-8\r\n&quot;
                response_headers += &quot;Content-Length:%d\r\n&quot; % len(response_body)
                response_headers += &quot;\r\n&quot;

                send_data = response_headers.encode(&quot;utf-8&quot;) + response_body

                client_socket.send(send_data)

            else:
                content = f.read()
                f.close()

                # 响应的body信息
                response_body = content
                # 响应头信息
                response_headers = &quot;HTTP/1.1 200 OK\r\n&quot;
                response_headers += &quot;Content-Type:text/html;charset=utf-8\r\n&quot;
                response_headers += &quot;Content-Length:%d\r\n&quot; % len(response_body)
                response_headers += &quot;\r\n&quot;
                send_data = response_headers.encode(&quot;utf-8&quot;) + response_body
                client_socket.send(send_data)

# 设置服务器服务静态资源时的路径
DOCUMENTS_ROOT = &quot;./html&quot;

def main():
    &quot;&quot;&quot;控制web服务器整体&quot;&quot;&quot;
    # python3 xxxx.py 7890
    if len(sys.argv) == 2:
        port = sys.argv[1]
        if port.isdigit():
            port = int(port)
    else:
        print(&quot;运行方式如: python3 xxx.py 7890&quot;)
        return

    print(&quot;http服务器使用的port:%s&quot; % port)
    http_server = WSGIServer(port, DOCUMENTS_ROOT&quot;)
    http_server.run_forever()


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/KingDragon-Baron/2018/11/08/线程、进程、协程实现多任务/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Baron">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King Dragon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/08/线程、进程、协程实现多任务/" itemprop="url">线程、进程、协程实现多任务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-08T23:47:41+08:00">
                2018-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程、进程、协程"><a href="#线程、进程、协程" class="headerlink" title="线程、进程、协程"></a>线程、进程、协程</h2><hr>
<h4 id="1-线程"><a href="#1-线程" class="headerlink" title="1.线程"></a>1.线程</h4><h6 id="多线程的简单实现"><a href="#多线程的简单实现" class="headerlink" title="多线程的简单实现"></a>多线程的简单实现</h6><pre><code>#coding=utf-8
import threading
from time import sleep,ctime

def sing():
    for i in range(3):
        print(&quot;正在唱歌...%d&quot;%i)
        sleep(1)

def dance():
    for i in range(3):
        print(&quot;正在跳舞...%d&quot;%i)
        sleep(1)

if __name__ == &apos;__main__&apos;:
    print(&apos;---开始---:%s&apos;%ctime())

    t1 = threading.Thread(target=sing)
    t2 = threading.Thread(target=dance)

    t1.start()
    t2.start()

    print(&apos;---结束---:%s&apos;%ctime())
</code></pre><h6 id="多线程实现多任务版udp聊天器"><a href="#多线程实现多任务版udp聊天器" class="headerlink" title="多线程实现多任务版udp聊天器"></a>多线程实现多任务版udp聊天器</h6><pre><code>import socket
import threading


def send_msg(udp_socket):
    &quot;&quot;&quot;获取键盘数据，并将其发送给对方&quot;&quot;&quot;
    while True:
        # 1. 从键盘输入数据
        msg = input(&quot;\n请输入要发送的数据:&quot;)
        # 2. 输入对方的ip地址
        dest_ip = input(&quot;\n请输入对方的ip地址:&quot;)
        # 3. 输入对方的port
        dest_port = int(input(&quot;\n请输入对方的port:&quot;))
        # 4. 发送数据
        udp_socket.sendto(msg.encode(&quot;utf-8&quot;), (dest_ip, dest_port))


def recv_msg(udp_socket):
    &quot;&quot;&quot;接收数据并显示&quot;&quot;&quot;
    while True:
        # 1. 接收数据
        recv_msg = udp_socket.recvfrom(1024)
        # 2. 解码
        recv_ip = recv_msg[1]
        recv_msg = recv_msg[0].decode(&quot;utf-8&quot;)
        # 3. 显示接收到的数据
        print(&quot;&gt;&gt;&gt;%s:%s&quot; % (str(recv_ip), recv_msg))


def main():
    # 1. 创建套接字
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    # 2. 绑定本地信息
    udp_socket.bind((&quot;&quot;, 7890))

    # 3. 创建一个子线程用来接收数据
    t = threading.Thread(target=recv_msg, args=(udp_socket,))
    t.start()
    # 4. 让主线程用来检测键盘数据并且发送
    send_msg(udp_socket)

if __name__ == &quot;__main__&quot;:
    main()
</code></pre><h4 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h4><h6 id="多进程的简单实现"><a href="#多进程的简单实现" class="headerlink" title="多进程的简单实现"></a>多进程的简单实现</h6><pre><code># -*- coding:utf-8 -*-

# 修改import中的Queue为Manager
from multiprocessing import Manager,Pool
import os,time,random

def reader(q):
    print(&quot;reader启动(%s),父进程为(%s)&quot; % (os.getpid(), os.getppid()))
    for i in range(q.qsize()):
        print(&quot;reader从Queue获取到消息：%s&quot; % q.get(True))

def writer(q):
    print(&quot;writer启动(%s),父进程为(%s)&quot; % (os.getpid(), os.getppid()))
    for i in &quot;itcast&quot;:
        q.put(i)

if __name__==&quot;__main__&quot;:
    print(&quot;(%s) start&quot; % os.getpid())
    q = Manager().Queue()  # 使用Manager中的Queue
    po = Pool()
    po.apply_async(writer, (q,))

    time.sleep(1)  # 先让上面的任务向Queue存入数据，然后再让下面的任务开始从中取数据

    po.apply_async(reader, (q,))
    po.close()  # 关闭进程池，关闭后po不再接收新的请求
    po.join()  # 等待po中所有子进程执行完成，必须放在close语句之后
    print(&quot;(%s) End&quot; % os.getpid())
</code></pre><h6 id="文件夹copy器（多进程版）"><a href="#文件夹copy器（多进程版）" class="headerlink" title="文件夹copy器（多进程版）"></a>文件夹copy器（多进程版）</h6><pre><code>import multiprocessing
import os
import time
import random


def copy_file(queue, file_name,source_folder_name,  dest_folder_name):
    &quot;&quot;&quot;copy文件到指定的路径&quot;&quot;&quot;
    f_read = open(source_folder_name + &quot;/&quot; + file_name, &quot;rb&quot;)
    f_write = open(dest_folder_name + &quot;/&quot; + file_name, &quot;wb&quot;)
    while True:
        time.sleep(random.random())
        content = f_read.read(1024)
        if content:
            f_write.write(content)
        else:
            break
    f_read.close()
    f_write.close()

    # 发送已经拷贝完毕的文件名字
    queue.put(file_name)


def main():
    # 获取要复制的文件夹
    source_folder_name = input(&quot;请输入要复制文件夹名字:&quot;)

    # 整理目标文件夹
    dest_folder_name = source_folder_name + &quot;[副本]&quot;

    # 创建目标文件夹
    try:
        os.mkdir(dest_folder_name)
    except:
        pass  # 如果文件夹已经存在，那么创建会失败

    # 获取这个文件夹中所有的普通文件名
    file_names = os.listdir(source_folder_name)

    # 创建Queue
    queue = multiprocessing.Manager().Queue()

    # 创建进程池
    pool = multiprocessing.Pool(3)

    for file_name in file_names:
        # 向进程池中添加任务
        pool.apply_async(copy_file, args=(queue, file_name, source_folder_name, dest_folder_name))

    # 主进程显示进度
    pool.close()

    all_file_num = len(file_names)
    while True:
        file_name = queue.get()
        if file_name in file_names:
            file_names.remove(file_name)

        copy_rate = (all_file_num-len(file_names))*100/all_file_num
        print(&quot;\r%.2f...(%s)&quot; % (copy_rate, file_name) + &quot; &quot;*50, end=&quot;&quot;)
        if copy_rate &gt;= 100:
            break
    print()


if __name__ == &quot;__main__&quot;:
    main()
</code></pre><h4 id="3-协程"><a href="#3-协程" class="headerlink" title="3.协程"></a>3.协程</h4><h6 id="多协程的简单实现"><a href="#多协程的简单实现" class="headerlink" title="多协程的简单实现"></a>多协程的简单实现</h6><pre><code>import time
</code></pre><p>(1).yield关键字<br>    def work1():<br>        while True:<br>            print(“—-work1—“)<br>            yield<br>            time.sleep(0.5)</p>
<pre><code>def work2():
    while True:
        print(&quot;----work2---&quot;)
        yield
        time.sleep(0.5)

def main():
    w1 = work1()
    w2 = work2()
    while True:
        next(w1)
        next(w2)

if __name__ == &quot;__main__&quot;:
    main()
</code></pre><p>(2).greenlet实现协程</p>
<pre><code>#coding=utf-8

from greenlet import greenlet
import time

def test1():
    while True:
        print &quot;---A--&quot;
        gr2.switch()
        time.sleep(0.5)

def test2():
    while True:
        print &quot;---B--&quot;
        gr1.switch()
        time.sleep(0.5)

gr1 = greenlet(test1)
gr2 = greenlet(test2)

#切换到gr1中运行
gr1.switch()
</code></pre><p>(3).gevent实现协程</p>
<pre><code>from gevent import monkey
import gevent
import random
import time

# 有耗时操作时需要
monkey.patch_all()  # 将程序中用到的耗时操作的代码，换为gevent中自己实现的模块

def coroutine_work(coroutine_name):
    for i in range(10):
        print(coroutine_name, i)
        time.sleep(random.random())

gevent.joinall([
        gevent.spawn(coroutine_work, &quot;work1&quot;),
        gevent.spawn(coroutine_work, &quot;work2&quot;)
])
</code></pre><h6 id="并发下载器"><a href="#并发下载器" class="headerlink" title="并发下载器"></a>并发下载器</h6><pre><code>from gevent import monkey
import gevent
import urllib.request

#有IO才做时需要这一句
monkey.patch_all()

def my_downLoad(file_name, url):
    print(&apos;GET: %s&apos; % url)
    resp = urllib.request.urlopen(url)
    data = resp.read()

    with open(file_name, &quot;wb&quot;) as f:
        f.write(data)

    print(&apos;%d bytes received from %s.&apos; % (len(data), url))

gevent.joinall([
        gevent.spawn(my_downLoad, &quot;1.mp4&quot;, &apos;资源地址&apos;),
        gevent.spawn(my_downLoad, &quot;2.mp4&quot;, &apos;资源地址&apos;),
])
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/KingDragon-Baron/2018/11/08/udp网络编程基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Baron">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King Dragon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/08/udp网络编程基础/" itemprop="url">udp网络编程基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-08T23:47:12+08:00">
                2018-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="udp网络程序-发送、接收数据"><a href="#udp网络程序-发送、接收数据" class="headerlink" title="udp网络程序-发送、接收数据"></a>udp网络程序-发送、接收数据</h2><hr>
<h4 id="1-udp网络程序-发送数据"><a href="#1-udp网络程序-发送数据" class="headerlink" title="1. udp网络程序-发送数据"></a>1. udp网络程序-发送数据</h4><p>创建一个基于udp的网络程序流程很简单，具体步骤如下：</p>
<p>1.创建客户端套接字<br>2.发送/接收数据<br>3.关闭套接字</p>
<p>代码如下：</p>
<p>  #coding=utf-8</p>
<p>  from socket import *</p>
<h1 id="1-创建udp套接字"><a href="#1-创建udp套接字" class="headerlink" title="1. 创建udp套接字"></a>1. 创建udp套接字</h1><p>  udp_socket = socket(AF_INET, SOCK_DGRAM)</p>
<h1 id="2-准备接收方的地址"><a href="#2-准备接收方的地址" class="headerlink" title="2. 准备接收方的地址"></a>2. 准备接收方的地址</h1><h1 id="‘192-168-1-103’表示目的ip地址"><a href="#‘192-168-1-103’表示目的ip地址" class="headerlink" title="‘192.168.1.103’表示目的ip地址"></a>‘192.168.1.103’表示目的ip地址</h1><h1 id="8080表示目的端口"><a href="#8080表示目的端口" class="headerlink" title="8080表示目的端口"></a>8080表示目的端口</h1><p>  dest_addr = (‘192.168.1.103’, 8080)  # 注意 是元组，ip是字符串，端口是数字</p>
<h1 id="3-从键盘获取数据"><a href="#3-从键盘获取数据" class="headerlink" title="3. 从键盘获取数据"></a>3. 从键盘获取数据</h1><p>  send_data = input(“请输入要发送的数据:”)</p>
<h1 id="4-发送数据到指定的电脑上的指定程序中"><a href="#4-发送数据到指定的电脑上的指定程序中" class="headerlink" title="4. 发送数据到指定的电脑上的指定程序中"></a>4. 发送数据到指定的电脑上的指定程序中</h1><p>  udp_socket.sendto(send_data.encode(‘utf-8’), dest_addr)</p>
<h1 id="5-关闭套接字"><a href="#5-关闭套接字" class="headerlink" title="5. 关闭套接字"></a>5. 关闭套接字</h1><p>  udp_socket.close()</p>
<h4 id="2-udp网络程序-发送、接收数据"><a href="#2-udp网络程序-发送、接收数据" class="headerlink" title="2. udp网络程序-发送、接收数据"></a>2. udp网络程序-发送、接收数据</h4><p>代码如下：</p>
<p>  #coding=utf-8</p>
<p>  from socket import *</p>
<h1 id="1-创建udp套接字-1"><a href="#1-创建udp套接字-1" class="headerlink" title="1. 创建udp套接字"></a>1. 创建udp套接字</h1><p>  udp_socket = socket(AF_INET, SOCK_DGRAM)</p>
<h1 id="2-准备接收方的地址-1"><a href="#2-准备接收方的地址-1" class="headerlink" title="2. 准备接收方的地址"></a>2. 准备接收方的地址</h1><p>  dest_addr = (‘192.168.236.129’, 8080)</p>
<h1 id="3-从键盘获取数据-1"><a href="#3-从键盘获取数据-1" class="headerlink" title="3. 从键盘获取数据"></a>3. 从键盘获取数据</h1><p>  send_data = input(“请输入要发送的数据:”)</p>
<h1 id="4-发送数据到指定的电脑上"><a href="#4-发送数据到指定的电脑上" class="headerlink" title="4. 发送数据到指定的电脑上"></a>4. 发送数据到指定的电脑上</h1><p>  udp_socket.sendto(send_data.encode(‘utf-8’), dest_addr)</p>
<h1 id="5-等待接收对方发送的数据"><a href="#5-等待接收对方发送的数据" class="headerlink" title="5. 等待接收对方发送的数据"></a>5. 等待接收对方发送的数据</h1><p>  recv_data = udp_socket.recvfrom(1024)  # 1024表示本次接收的最大字节数</p>
<h1 id="6-显示对方发送的数据"><a href="#6-显示对方发送的数据" class="headerlink" title="6. 显示对方发送的数据"></a>6. 显示对方发送的数据</h1><h1 id="接收到的数据recv-data是一个元组"><a href="#接收到的数据recv-data是一个元组" class="headerlink" title="接收到的数据recv_data是一个元组"></a>接收到的数据recv_data是一个元组</h1><h1 id="第1个元素是对方发送的数据"><a href="#第1个元素是对方发送的数据" class="headerlink" title="第1个元素是对方发送的数据"></a>第1个元素是对方发送的数据</h1><h1 id="第2个元素是对方的ip和端口"><a href="#第2个元素是对方的ip和端口" class="headerlink" title="第2个元素是对方的ip和端口"></a>第2个元素是对方的ip和端口</h1><p>  print(recv_data[0].decode(‘gbk’))<br>  print(recv_data[1])</p>
<h1 id="可以简写成"><a href="#可以简写成" class="headerlink" title="可以简写成"></a>可以简写成</h1><h1 id="recv-data-client-addr-udp-socket-recvfrom-1024"><a href="#recv-data-client-addr-udp-socket-recvfrom-1024" class="headerlink" title="recv_data, client_addr = udp_socket.recvfrom(1024)"></a>recv_data, client_addr = udp_socket.recvfrom(1024)</h1><h1 id="7-关闭套接字"><a href="#7-关闭套接字" class="headerlink" title="7. 关闭套接字"></a>7. 关闭套接字</h1><p>  udp_socket.close()</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/KingDragon-Baron/2018/11/08/tcp网络编程基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Baron">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King Dragon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/08/tcp网络编程基础/" itemprop="url">tcp网络编程基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-08T23:46:33+08:00">
                2018-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="tcp网络编程基础"><a href="#tcp网络编程基础" class="headerlink" title="tcp网络编程基础"></a>tcp网络编程基础</h2><hr>
<h4 id="1-tcp客户端"><a href="#1-tcp客户端" class="headerlink" title="1.tcp客户端"></a>1.tcp客户端</h4><p>  from socket import *</p>
<h1 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h1><p>  tcp_client_socket = socket(AF_INET, SOCK_STREAM)</p>
<h1 id="目的信息"><a href="#目的信息" class="headerlink" title="目的信息"></a>目的信息</h1><p>  server_ip = input(“请输入服务器ip:”)<br>  server_port = int(input(“请输入服务器port:”))</p>
<h1 id="链接服务器"><a href="#链接服务器" class="headerlink" title="链接服务器"></a>链接服务器</h1><p>  tcp_client_socket.connect((server_ip, server_port))</p>
<h1 id="提示用户输入数据"><a href="#提示用户输入数据" class="headerlink" title="提示用户输入数据"></a>提示用户输入数据</h1><p>  send_data = input(“请输入要发送的数据：”)</p>
<p>  tcp_client_socket.send(send_data.encode(“gbk”))</p>
<h1 id="接收对方发送过来的数据，最大接收1024个字节"><a href="#接收对方发送过来的数据，最大接收1024个字节" class="headerlink" title="接收对方发送过来的数据，最大接收1024个字节"></a>接收对方发送过来的数据，最大接收1024个字节</h1><p>  recvData = tcp_client_socket.recv(1024)<br>  print(‘接收到的数据为:’, recvData.decode(‘gbk’))</p>
<h1 id="关闭套接字"><a href="#关闭套接字" class="headerlink" title="关闭套接字"></a>关闭套接字</h1><p>  tcp_client_socket.close()</p>
<h4 id="2-tcp服务器"><a href="#2-tcp服务器" class="headerlink" title="2.tcp服务器"></a>2.tcp服务器</h4><p>流程如下：<br>1.socket创建一个套接字<br>2.bind绑定ip和port<br>3.listen使套接字变为可以被动链接<br>4.accept等待客户端的链接<br>5.recv/send接收发送数据</p>
<p>代码如下：<br>  from socket import *</p>
<h1 id="创建socket-1"><a href="#创建socket-1" class="headerlink" title="创建socket"></a>创建socket</h1><p>  tcp_server_socket = socket(AF_INET, SOCK_STREAM)</p>
<h1 id="本地信息（不写ip默认本机127-0-0-1）"><a href="#本地信息（不写ip默认本机127-0-0-1）" class="headerlink" title="本地信息（不写ip默认本机127.0.0.1）"></a>本地信息（不写ip默认本机127.0.0.1）</h1><p>  address = (‘127.0.0.1’, 7788)</p>
<h1 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h1><p>  tcp_server_socket.bind(address)</p>
<h1 id="使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了"><a href="#使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了" class="headerlink" title="使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了"></a>使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了</h1><p>  #监听<br>  tcp_server_socket.listen(128)</p>
<h1 id="如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务"><a href="#如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务" class="headerlink" title="如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务"></a>如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务</h1><h1 id="client-socket用来为这个客户端服务"><a href="#client-socket用来为这个客户端服务" class="headerlink" title="client_socket用来为这个客户端服务"></a>client_socket用来为这个客户端服务</h1><h1 id="tcp-server-socket就可以省下来专门等待其他新客户端的链接"><a href="#tcp-server-socket就可以省下来专门等待其他新客户端的链接" class="headerlink" title="tcp_server_socket就可以省下来专门等待其他新客户端的链接"></a>tcp_server_socket就可以省下来专门等待其他新客户端的链接</h1><p>  client_socket, clientAddr = tcp_server_socket.accept()</p>
<h1 id="接收对方发送过来的数据"><a href="#接收对方发送过来的数据" class="headerlink" title="接收对方发送过来的数据"></a>接收对方发送过来的数据</h1><p>  recv_data = client_socket.recv(1024)  # 接收1024个字节<br>  print(‘接收到的数据为:’, recv_data.decode(‘gbk’))</p>
<h1 id="发送一些数据到客户端"><a href="#发送一些数据到客户端" class="headerlink" title="发送一些数据到客户端"></a>发送一些数据到客户端</h1><p>  client_socket.send(“thank you !”.encode(‘gbk’))</p>
<h1 id="关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接"><a href="#关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接" class="headerlink" title="关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接"></a>关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接</h1><p>  client_socket.close()</p>
<h4 id="3-tcp的3次握手"><a href="#3-tcp的3次握手" class="headerlink" title="3.tcp的3次握手"></a>3.tcp的3次握手</h4><p>  client(客户端连接connect)——–&gt;server(服务端监听listen)———&gt;client(服务端告诉客户端链接已建立)———-&gt;server(客户端告诉服务端链接已建立)</p>
<h4 id="4-tcp的4次挥手"><a href="#4-tcp的4次挥手" class="headerlink" title="4.tcp的4次挥手"></a>4.tcp的4次挥手</h4><p>  client(客户端告诉服务端要关闭链接close)<br>  —-&gt;server(服务端告诉客户端同意关闭链接close)<br>  —-&gt;client(服务端告诉客户端链接已关闭)<br>  server—-&gt;client(服务端将最后的数据传递给客户端)<br>  —-&gt;server(设置超时等待，确保最后达到关闭状态)</p>
<h4 id="5-tcp长连接和短连接"><a href="#5-tcp长连接和短连接" class="headerlink" title="5.tcp长连接和短连接"></a>5.tcp长连接和短连接</h4><ol>
<li><p>TCP短连接</p>
<p>client 向 server 发起连接请求<br>server 接到请求，双方建立连接<br>client 向 server 发送消息<br>server 回应 client<br>一次读写完成，此时双方任何一个都可以发起 close 操作<br>在步骤5中，一般都是 client 先发起 close 操作。当然也不排除有特殊的情况。</p>
<p>短连接一般只会在 client/server 间传递一次读写操作！</p>
</li>
<li><p>TCP长连接</p>
<p>client 向 server 发起连接<br>server 接到请求，双方建立连接<br>client 向 server 发送消息<br>server 回应 client<br>一次读写完成，连接不关闭<br>后续读写操作…<br>长时间操作之后client发起关闭请求</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/KingDragon-Baron/2018/09/27/webapp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Baron">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King Dragon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/27/webapp/" itemprop="url">webapp</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-27T13:56:39+08:00">
                2018-09-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="移动web学习总结"><a href="#移动web学习总结" class="headerlink" title="移动web学习总结"></a>移动web学习总结</h1><h2 id="1-响应式布局常见屏幕大小"><a href="#1-响应式布局常见屏幕大小" class="headerlink" title="1. 响应式布局常见屏幕大小"></a>1. 响应式布局常见屏幕大小</h2><pre><code>1. 大电脑（笔记本 大台式机）：屏幕判断是&gt;1200都是大电脑 大屏幕
2. 小电脑（老的台式机）： 屏幕&gt;992 并且 &lt; 1200         中屏幕
3. 平板电脑（ipad） : 屏幕 &gt; 768 并且 &lt; 992           小屏幕
4. 手机 ： 屏幕 &lt; 768                                超小屏幕
</code></pre><h2 id="2-媒体查询"><a href="#2-媒体查询" class="headerlink" title="2. 媒体查询"></a>2. 媒体查询</h2><pre><code>语法: @media(条件){属性}
例子:    @media(min-width: 1200px){
            div,span {
                width:25%;
              }
          }
</code></pre><h2 id="3-响应式开发框架"><a href="#3-响应式开发框架" class="headerlink" title="3. 响应式开发框架"></a>3. 响应式开发框架</h2><ol>
<li><a href="http://www.bootcss.com/" target="_blank" rel="noopener">bootstrap 框架</a></li>
<li><a href="http://amazeui.org/" target="_blank" rel="noopener">AmazeUI</a></li>
<li><a href="http://dev.dcloud.net.cn/mui/" target="_blank" rel="noopener">MUI</a></li>
<li><a href="https://www.layui.com/" target="_blank" rel="noopener">Layui</a></li>
</ol>
<h2 id="4-全局css初始化样式"><a href="#4-全局css初始化样式" class="headerlink" title="4. 全局css初始化样式"></a>4. 全局css初始化样式</h2><pre><code>/*reset css*/
*,::before,::after{
    margin:0;
    padding:0;
    /*清除移动端默认的点击高亮效果*/
    -webkit-tap-highlight-color:transparent;
    /*设置以边框开始计算宽度*/
    -webkit-box-sizing:border-box;
    box-sizing:border-box;
}

body{
    font-size:14px;
    font-family:&quot;Microsoft YaHei&quot;,sans-serif;/*设备默认字体*/
    color:#333;
}

a{
    color:#333;
    text-decoration:none;
}

a:hover{
    text-decoration:none;
}

ul,ol{
    list-style:none;
}

input{
    border:none;
    outline:none;
    /*清除移动端默认的表单样式*/
    -webkit-appearance:none;
}

.clearfix::before,.clearfix::after{
    content:&quot;&quot;;
    height:0;
    line-height:0;
    display:block;
    visibility:hidden;
    clear:both;
}
</code></pre><h2 id="5-如何去生成自己的字体图标"><a href="#5-如何去生成自己的字体图标" class="headerlink" title="5. 如何去生成自己的字体图标"></a>5. 如何去生成自己的字体图标</h2><ol>
<li>获取到字体图标文件(如:阿里图标库官网 <a href="http://www.iconfont.cn/" target="_blank" rel="noopener">http://www.iconfont.cn/</a>)</li>
<li>创建了一个iconfont.css文件,创建一个属于你的字体<pre><code>@font-face {
    font-family: &quot;iconfont&quot;;
    /*还要指定src字体文件的路径*/ 
    /*如果要兼容不同浏览器就要引入多个字体文件(eot svg ttf woff)
    同时要format声明这个字体文件的类型*/
    src:url(&apos;iconfont.ttf?t=1535163749373&apos;) format(&apos;truetype&apos;);
  }
</code></pre></li>
<li>使用字体<pre><code>/*公共类 来使用图标字体*/
  .iconfont {
    font-family:&quot;icon&quot; !important;
    font-size:16px;
    font-style:normal;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  } 
</code></pre></li>
<li>使用图标的编码 <pre><code>.icon-staroff:before { content: &quot;\e618&quot;; }
</code></pre></li>
</ol>
<h2 id="6-手机调试"><a href="#6-手机调试" class="headerlink" title="6. 手机调试"></a>6. 手机调试</h2><pre><code>1. 原理： 让手机和电脑在同一个网络 使用局域网的方式访问
2. 如何让手机和电脑在一个网络
    1. 手机和电脑连接同一个wifi
    2. 用电脑开wifi给手机连接
    3. 用手机开热点 电脑连接

3. 使用手机开热点电脑连接
  1. 手机打开热点
  2. 电脑连接wifi 连接手机放出来wifi
  3. 查看wifi的ip地址 （就是你手机网络的地址
  4. 关闭防火墙
4. 使用电脑开启网页服务sublimer vscode等都可以  webstrome不可以
  1. 开启网页服务器后 把localost换成当前wifi的ip地址 
  2. 刷新页面 如果能够打开表示ip正常
5. 通过二维码插件扫码 微信扫不开 用浏览器扫码 或者 直接把整个网址发送到手机上就可以打
</code></pre><h2 id="7-物理像素-逻辑像素-真实像素"><a href="#7-物理像素-逻辑像素-真实像素" class="headerlink" title="7. 物理像素/逻辑像素/真实像素"></a>7. 物理像素/逻辑像素/真实像素</h2><pre><code>1. 物理分辨率像素： 设备的屏幕上的最小单元 相当于屏幕里面每一个小格子 1个格子就是1px       硬件决定的  屏幕分辨率是多大就是多大
2. 逻辑像素(CSS像素): 逻辑单位 相当于视口里面每一个小格子  1个格子也是1px       跟随视口的变化而变化
3. 设备真实像素： 模拟器里面375*667  320*568 设备屏幕真实的大小        也是固定的屏幕多大就是多大
4. 逻辑像素和真实像素的关系： 因为移动开发一般会把视口的宽度设置为设备的真实宽度就表示       逻辑像素和真实像素是一样
5. 逻辑像素和分辨率像素的关系： 
    1. 分辨率像素在手机上通常和真实像素 是不一样的
        iphone5 320*568   640 * 1136
        iphone678 375*667  750 * 1334
        通常手机屏幕分辨率比真实的像素大2倍
        分辨率的像素也比逻辑像素大2倍
    2. 2个分辨率的px 宽度  = 1CSSpx  宽度
    3. 除了2倍 还有iphonex   375* 812   1125*2436 
      屏幕的分辨率 比真实像素大3倍
      分辨率像素 也比逻辑像素3倍
      在iphonex 3px 宽度 = 1 CSSpx 宽度
</code></pre><p>[移动端其他常识] (<a href="http://www.woshipm.com/pmd/176328.html" target="_blank" rel="noopener">http://www.woshipm.com/pmd/176328.html</a>)</p>
<ol>
<li>dpr: 设备像素比 分辨率和真实像素的比率</li>
<li>ppi: 一英寸里面的px数量 </li>
<li>dpi: 1英寸的点数量</li>
<li>px pt 单位 英寸单位 em rem单位等</li>
</ol>
<h2 id="8-常见的网页的布局方式"><a href="#8-常见的网页的布局方式" class="headerlink" title="8. 常见的网页的布局方式"></a>8. 常见的网页的布局方式</h2><pre><code>1. 固定宽高布局
2. 百分比布局
3. 伸缩布局flex布局
4. 响应式布局
5. 把伸缩+百分比结合在一起  伸缩百分比布局
6. rem布局
</code></pre><h2 id="9-rem布局详解"><a href="#9-rem布局详解" class="headerlink" title="9. rem布局详解"></a>9. rem布局详解</h2><h3 id="rem是什么"><a href="#rem是什么" class="headerlink" title="rem是什么"></a>rem是什么</h3><ol>
<li>rem是什么：rem root element 根元素(html元素) 是一个单位 这个单位的大小参照根元素的字体大小</li>
</ol>
<h3 id="rem的好处"><a href="#rem的好处" class="headerlink" title="rem的好处"></a>rem的好处</h3><ol>
<li>rem大小是固定参照根元素的font-size  使用的时候rem值相对统一</li>
<li>只需要修改根元素的font-size 可以实现全局修改 可以实现修改根元素字体大小实现全屏的缩放</li>
<li>实现自适应缩放布局</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/KingDragon-Baron/2018/09/24/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Baron">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King Dragon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/24/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-24T11:20:06+08:00">
                2018-09-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>久利之事勿为，众争之地勿往；<br>勿以小恶弃人大美，勿以小怨忘人大恩；<br>说人之短乃护己之短，夸己之长乃忌人之长；<br>利可共而不可独，谋可寡而不可众；<br>天下古今之庸人，皆以一惰字致败，天下古今之才人，皆以一傲字致败；<br>凡成大事，以识为主，以才为辅，人谋居半，天意居半。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="Baron" />
            
              <p class="site-author-name" itemprop="name">Baron</p>
              <p class="site-description motion-element" itemprop="description">Baron个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/KingDragon-Baron" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:ecustfengyun@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/ecustfengyun" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Baron</span>

  
</div>


  <div class="powered-by">个人专属</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">博客-Baron &mdash; NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
